<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Moon Shot Map Planner ğŸŒ•</title>
    <style>
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }
        #map { width: 100%; height: 85vh; }
        .controls {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 5;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            display: flex;
            gap: 10px;
            align-items: center;
        }
        input, button { padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px; }
        button { background: #4285F4; color: white; border: none; cursor: pointer; font-weight: bold; }
        button:hover { background: #3367d6; }
        #info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 5;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            color: #333;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            text-align: center;
        }
    </style>
    <!-- SunCalc ë¼ì´ë¸ŒëŸ¬ë¦¬ (ë‹¬ ìœ„ì¹˜ ê³„ì‚°ìš©) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.9.0/suncalc.min.js"></script>
    <script>
        // ì •ë°€ë„ í–¥ìƒì„ ìœ„í•œ Topocentric(ì§€í‘œë©´ ê¸°ì¤€) ë³´ì • í•¨ìˆ˜ ì¶”ê°€
        // SunCalcëŠ” Geocentric(ì§€êµ¬ ì¤‘ì‹¬) ì¢Œí‘œë¥¼ ë°˜í™˜í•˜ë¯€ë¡œ, ê´€ì¸¡ì ìœ„ì¹˜ì— ë”°ë¥¸ ì‹œì°¨(Parallax)ë¥¼ ë³´ì •í•´ì•¼ í•¨.
        
        function getCorrectedMoonPosition(date, lat, lng, elevMeters = 0) {
            // 1. SunCalcë¡œ Geocentric ì¢Œí‘œ íšë“
            const pos = SunCalc.getMoonPosition(date, lat, lng);
            
            // 2. Parallax (ì‹œì°¨) ë³´ì • - ë‹¬ì€ ì§€êµ¬ ì¤‘ì‹¬ë³´ë‹¤ ì§€í‘œë©´ì—ì„œ ë³¼ ë•Œ ë” 'ë‚®ê²Œ' ë³´ì…ë‹ˆë‹¤.
            // tan(p) = (R/D) * cos(h)
            // p = HP * cos(h)
            
            const distKm = pos.distance; 
            const earthRadiusKm = 6371;
            const horizontalParallax = Math.asin(earthRadiusKm / distKm); // ë¼ë””ì•ˆ
            
            // Topocentric Altitude = Geocentric Altitude - Parallax * cos(Altitude)
            // (ì§€í‰ì„  ê·¼ì²˜ì—ì„œ ìµœëŒ€ ì•½ 1ë„(57ë¶„) ì°¨ì´ ë°œìƒ)
            let topoAltitude = pos.altitude - horizontalParallax * Math.cos(pos.altitude);
            
            // 3. Refraction (ëŒ€ê¸° êµ´ì ˆ) ë³´ì • - ì²œì²´ë¥¼ 'ë” ë†’ê²Œ' ë³´ì´ê²Œ í•©ë‹ˆë‹¤.
            // Apparent Altitude = Topocentric Altitude + Refraction
            // Bennett Formula Approximation (Saemundsson formula)
            
            const h = topoAltitude * 180 / Math.PI; // ë„(deg) ë‹¨ìœ„
            let refraction = 0;
            
            // ì§€í‰ì„  ì•„ë˜ ë„ˆë¬´ ê¹Šìœ¼ë©´ ì˜ë¯¸ ì—†ìŒ (-2ë„ ì´ìƒì¼ ë•Œë§Œ ì ìš©)
            if (h > -2.0) {
                // R (arcmin) = 1.02 / tan(h + 10.3 / (h + 5.11))
                // hëŠ” ë°˜ë“œì‹œ ì–‘ìˆ˜ ë³´ì • í•„ìš” (ìˆ˜í‰ì„  ê·¼ì²˜ ë°œì‚° ë°©ì§€)
                const hSafe = Math.max(-0.5, h); 
                const rArcMin = 1.02 / Math.tan((hSafe + 10.3 / (hSafe + 5.11)) * Math.PI / 180);
                refraction = rArcMin / 60; // ë„(deg) ë‹¨ìœ„
            }
            
            const apparentAltitude = (h + refraction) * Math.PI / 180; // ë¼ë””ì•ˆ ì¬ë³€í™˜

            return {
                azimuth: pos.azimuth, // ë°©ìœ„ê°ì€ ì‹œì°¨ ì˜í–¥ì´ ë§¤ìš° ì ìœ¼ë¯€ë¡œ ê·¸ëŒ€ë¡œ ì‚¬ìš©
                altitude: apparentAltitude,
                distance: distKm,
                parallacticAngle: pos.parallacticAngle
            };
        }
    </script>
</head>
<body>

    <div class="controls">
        <label>ğŸ“… ì´¬ì˜ ë‚ ì§œ:</label>
        <input type="date" id="dateInput">
        <label>ëŒ€ìƒì˜ ë†’ì´:</label>
        <input type="number" id="targetObjectHeight" placeholder="m" style="width: 60px;" value="0">
        <select id="mapTypeSelect" onchange="changeMapType()" style="padding: 8px; border-radius: 4px; border: 1px solid #ccc;">
            <option value="roadmap" selected>ê¸°ë³¸ì§€ë„</option>
            <option value="satellite">ìœ„ì„±ì§€ë„</option>
            <option value="terrain">ì§€í˜•ì§€ë„</option>
        </select>
        <button onclick="calculateAndDraw()">ğŸŒ‘ ì›”ì¶œ/ì›”ëª° ë¼ì¸ ê·¸ë¦¬ê¸°</button>
    </div>
    
    <!-- ìœ„ì¹˜ ê²€ìƒ‰ ì…ë ¥ì°½ -->
    <input id="pac-input" class="controls" type="text" placeholder="ì¥ì†Œ ê²€ìƒ‰ (ì˜ˆ: Nì„œìš¸íƒ€ì›Œ)" 
           style="position: absolute; top: 70px; left: 50%; transform: translateX(-50%); z-index: 5; width: 300px; padding: 10px; border-radius: 4px; border: 1px solid #ccc; font-size: 14px;">

    <div id="map"></div>
    <div id="info">ğŸ“ ì§€ë„ì—ì„œ ì´¬ì˜í•˜ê³  ì‹¶ì€ ëŒ€ìƒ(Target)ì„ í´ë¦­í•˜ì„¸ìš”.</div>
    
    <!-- ì´¬ì˜ëŒ€ìƒ ì´ˆê¸°í™” ë²„íŠ¼ -->
    <button onclick="resetTarget()" style="position: absolute; bottom: 30px; right: 20px; z-index: 10; padding: 10px 15px; background: white; color: #333; border: 1px solid #ccc; box-shadow: 0 2px 4px rgba(0,0,0,0.2); font-weight: bold; cursor: pointer; border-radius: 4px;">
        ğŸ”„ ì´¬ì˜ëŒ€ìƒ ì´ˆê¸°í™”
    </button>

    <!--
      âš ï¸ ì¤‘ìš”: YOUR_API_KEY_HERE ë¶€ë¶„ì„ ë³¸ì¸ì˜ Google Maps API Keyë¡œ êµì²´í•´ì•¼ ì§€ë„ê°€ ë³´ì…ë‹ˆë‹¤.
      Maps JavaScript API ë° Places APIê°€ í™œì„±í™”ë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.
    -->
    <script>
        // Google Maps API ë¡œë“œ
        function loadScript() {
            var script = document.createElement('script');
            // ì„¤ì •ëœ API Key
            var apiKey = 'AIzaSyDAaCinSoUTMv-amRHtiIEY-Hxp6TzcAOU';
            
            // Places API ë¼ì´ë¸ŒëŸ¬ë¦¬ í¬í•¨
            script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&callback=initMap&libraries=places`;
            script.async = true;
            script.defer = true;
            document.head.appendChild(script);
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ë°”ë¡œ ì§€ë„ ë¡œë“œ ì‹¤í–‰
        window.onload = loadScript;

        let map;
        let targetMarker = null;
        let shooterMarker = null;
        let moonrisePath = null;
        let moonsetPath = null;
        let shootingLinePath = null;
        let targetPosition = null;
        let shooterPosition = null;
        let elevator = null;
        let targetElevation = null;
        let shooterElevation = null;
        let isSelectingShooter = false; // ì´¬ì˜ ì¥ì†Œ ì„ íƒ ëª¨ë“œ ì—¬ë¶€

        // ì˜¤ëŠ˜ ë‚ ì§œë¡œ ì´ˆê¸°í™”
        document.getElementById('dateInput').valueAsDate = new Date();

        function resetTarget() {
            if (targetMarker) targetMarker.setMap(null);
            if (shooterMarker) shooterMarker.setMap(null);
            resetPaths();
            
            targetPosition = null;
            shooterPosition = null;
            targetMarker = null;
            shooterMarker = null;
            targetElevation = null;
            shooterElevation = null;
            isSelectingShooter = false;
            
            document.getElementById('targetObjectHeight').value = "0";
            document.getElementById('info').innerHTML = `ğŸ“ ì§€ë„ì—ì„œ ì´¬ì˜í•˜ê³  ì‹¶ì€ ëŒ€ìƒ(Target)ì„ í´ë¦­í•˜ì„¸ìš”.`;
        }

        function initMap() {
            // ì´ˆê¸° ìœ„ì¹˜: ì„œìš¸ ë‚¨ì‚°íƒ€ì›Œ
            const seoul = { lat: 37.5512, lng: 126.9882 };
            
            map = new google.maps.Map(document.getElementById("map"), {
                zoom: 13,
                center: seoul,
                mapTypeId: "roadmap", // ê¸°ë³¸ê°’ìœ¼ë¡œ ë¡œë“œë§µ ì„¤ì •
                streetViewControl: false,
                mapTypeControl: false // ê¸°ë³¸ ì»¨íŠ¸ë¡¤ ìˆ¨ê¹€ (ì§ì ‘ ì¶”ê°€í•œ select ì‚¬ìš©)
            });
            
            // Elevation ì„œë¹„ìŠ¤ ì´ˆê¸°í™”
            elevator = new google.maps.ElevationService();
            
            // ê²€ìƒ‰ì°½ (Places API) ì„¤ì •
            const input = document.getElementById("pac-input");
            const searchBox = new google.maps.places.SearchBox(input);
            
            // ê²€ìƒ‰ ê²°ê³¼ê°€ ì§€ë„ ê²½ê³„ ì•ˆìª½ ìœ„ì£¼ë¡œ ë‚˜ì˜¤ê²Œ ì„¤ì •
            map.addListener("bounds_changed", () => {
                searchBox.setBounds(map.getBounds());
            });

            // ì‚¬ìš©ìê°€ ê²€ìƒ‰ì–´ë¥¼ ì„ íƒí–ˆì„ ë•Œ ì´ë²¤íŠ¸
            searchBox.addListener("places_changed", () => {
                const places = searchBox.getPlaces();
                if (places.length == 0) return;

                // ê²€ìƒ‰ëœ ì¥ì†Œë¡œ ì§€ë„ ì´ë™
                const bounds = new google.maps.LatLngBounds();
                places.forEach((place) => {
                    if (!place.geometry || !place.geometry.location) return;

                    if (place.geometry.viewport) {
                        bounds.union(place.geometry.viewport);
                    } else {
                        bounds.extend(place.geometry.location);
                    }
                });
                map.fitBounds(bounds);
            });

            // ì§€ë„ í´ë¦­ ë¦¬ìŠ¤ë„ˆ
            map.addListener("click", (e) => {
                if (isSelectingShooter) {
                    setShooter(e.latLng);
                } else {
                    setTarget(e.latLng);
                }
            });
        }
        
        // ì§€ë„ ìœ í˜• ë³€ê²½ í•¨ìˆ˜
        function changeMapType() {
            const type = document.getElementById('mapTypeSelect').value;
            map.setMapTypeId(type);
        }

        function setTarget(latLng) {
            targetPosition = latLng;
            
            // ê¸°ì¡´ ë§ˆì»¤ ì œê±°
            if (targetMarker) targetMarker.setMap(null);
            
            // ìƒˆ ë§ˆì»¤ ìƒì„± (ë¹¨ê°„ìƒ‰ íƒ€ê²Ÿ ì•„ì´ì½˜)
            targetMarker = new google.maps.Marker({
                position: latLng,
                map: map,
                title: "ì´¬ì˜ ëŒ€ìƒ (Target)",
                icon: 'http://maps.google.com/mapfiles/ms/icons/red-dot.png' 
            });
            
            // ê¸°ì¡´ ì„  ì œê±° (ìƒˆ íƒ€ê²Ÿ ì„¤ì • ì‹œ ëª¨ë‘ ë¦¬ì…‹)
            resetPaths();
            if (shooterMarker) {
                shooterMarker.setMap(null);
                shooterMarker = null;
            }
            isSelectingShooter = false;

            // ë†’ì´ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
            getElevation(latLng, 'target');
        }

        function setShooter(latLng) {
            shooterPosition = latLng;

            if (shooterMarker) shooterMarker.setMap(null);

            shooterMarker = new google.maps.Marker({
                position: latLng,
                map: map,
                title: "ì´¬ì˜ ì¥ì†Œ (Shooter)",
                icon: 'http://maps.google.com/mapfiles/ms/icons/blue-dot.png'
            });

            // ë†’ì´ ì •ë³´ ê°€ì ¸ì˜¤ê¸° -> ê³„ì‚° ì‹¤í–‰
            getElevation(latLng, 'shooter');
        }

        function resetPaths() {
            if (moonrisePath) moonrisePath.setMap(null);
            if (moonsetPath) moonsetPath.setMap(null);
            if (shootingLinePath) shootingLinePath.setMap(null);
        }

        function getElevation(latLng, type) {
            const locations = [latLng];
            const request = { 'locations': locations };
            
            elevator.getElevationForLocations(request, function(results, status) {
                if (status === 'OK' && results[0]) {
                    const elev = results[0].elevation.toFixed(1);
                    if (type === 'target') {
                        targetElevation = parseFloat(elev);
                        document.getElementById('info').innerHTML = 
                            `ğŸ¯ íƒ€ê²Ÿ ì„¤ì • ì™„ë£Œ! (í•´ë°œ: ${targetElevation}m)<br>ë¬¼ì²´ ë†’ì´ ì…ë ¥ í›„ <strong>[ì›”ì¶œ/ì›”ëª° ë¼ì¸ ê·¸ë¦¬ê¸°]</strong> ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.`;
                    } else if (type === 'shooter') {
                        shooterElevation = parseFloat(elev);
                        calculateShootingMoment(); // ì´¬ì˜ ì¥ì†Œ ë†’ì´ê¹Œì§€ êµ¬í–ˆìœ¼ë©´ ë°”ë¡œ ê³„ì‚°
                    }
                } else {
                    console.log('Elevation service failed: ' + status);
                    if (type === 'target') targetElevation = 0;
                    if (type === 'shooter') shooterElevation = 0;
                }
            });
        }

        function calculateAndDraw() {
            if (!targetPosition) {
                alert("ì§€ë„ì—ì„œ ì´¬ì˜ ëŒ€ìƒì„ ë¨¼ì € í´ë¦­í•´ì£¼ì„¸ìš”!");
                return;
            }

            const dateStr = document.getElementById('dateInput').value;
            if (!dateStr) return;

            // ì„ íƒí•œ ë‚ ì§œì˜ ì •ì˜¤(12:00) ê¸°ì¤€ ê³„ì‚°
            const date = new Date(dateStr + "T12:00:00");
            const lat = targetPosition.lat();
            const lng = targetPosition.lng();

            resetPaths();

            // 0. ë‹¬ì˜ ìœ„ìƒ(Phase) ë° ì›”ë ¹ ê³„ì‚°
            const moonIllum = SunCalc.getMoonIllumination(date);
            const phase = moonIllum.phase; 
            const phaseName = getPhaseName(phase);
            const moonAge = (phase * 29.53).toFixed(1); 
            const moonIcon = getMoonPhaseIcon(phase);
            const moonTimes = SunCalc.getMoonTimes(date, lat, lng);
            
            let elevInfo = targetElevation ? ` (Target Elev: ${targetElevation}m)` : "";
            let infoText = `<div style="margin-bottom:8px; font-size:1.1em;">
                ${moonIcon} <strong>${phaseName}</strong> (ì›”ë ¹: ${moonAge}ì¼)${elevInfo}
            </div>`;
            
            let bounds = new google.maps.LatLngBounds();
            bounds.extend(targetPosition);

            // --- 1. ì›”ì¶œ (Moonrise) ---
            if (moonTimes.rise) {
                const risePos = SunCalc.getMoonPosition(moonTimes.rise, lat, lng);
                const riseAzimuth = (risePos.azimuth * 180 / Math.PI) + 180; 
                const shooterRiseAzimuth = (riseAzimuth + 180) % 360; 
                
                moonrisePath = drawShootingLine(targetPosition, shooterRiseAzimuth, "#1E90FF"); // íŒŒë€ìƒ‰
                
                const riseDateStr = moonTimes.rise.toLocaleDateString([], {month: 'numeric', day: 'numeric'});
                const riseTimeStr = moonTimes.rise.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                infoText += `<div id="rise-info">ğŸ”µ ì›”ì¶œ(Moonrise): <strong>${riseDateStr} ${riseTimeStr}</strong> (íŒŒë€ì„ )</div>`;
                bounds.extend(computeOffset(targetPosition, 5000, shooterRiseAzimuth));
            } else {
                infoText += `<div id="rise-info">ğŸ”µ ì›”ì¶œ ì—†ìŒ</div>`;
            }

            // --- 2. ì›”ëª° (Moonset) ---
            if (moonTimes.set) {
                const setPos = SunCalc.getMoonPosition(moonTimes.set, lat, lng);
                const setAzimuth = (setPos.azimuth * 180 / Math.PI) + 180;
                const shooterSetAzimuth = (setAzimuth + 180) % 360;

                moonsetPath = drawShootingLine(targetPosition, shooterSetAzimuth, "#FF8C00"); // ì£¼í™©ìƒ‰

                const setDateStr = moonTimes.set.toLocaleDateString([], {month: 'numeric', day: 'numeric'});
                const setTimeStr = moonTimes.set.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                infoText += `<div id="set-info">ğŸŸ  ì›”ëª°(Moonset): <strong>${setDateStr} ${setTimeStr}</strong> (ì£¼í™©ì„ )</div>`;
                bounds.extend(computeOffset(targetPosition, 5000, shooterSetAzimuth));
            } else {
                infoText += `<div id="set-info">ğŸŸ  ì›”ëª° ì—†ìŒ</div>`;
            }

            infoText += `<div id="shot-result" style="margin-top:10px; padding-top:10px; border-top:1px solid #eee;">
                ğŸ“¸ <strong>ì´ì œ ì§€ë„ì—ì„œ ì´¬ì˜ ì¥ì†Œ(Shooter)ë¥¼ í´ë¦­í•˜ì„¸ìš”.</strong><br>
                <span style="font-size:0.9em; color:#666;">(ìë™ìœ¼ë¡œ ë‹¬ì´ íƒ€ê²Ÿ ìœ„ë¡œ ì˜¬ë¼ì˜¤ëŠ” ì‹œê°ì„ ê³„ì‚°í•˜ì—¬ ì—¬ê¸°ì— í‘œì‹œí•©ë‹ˆë‹¤)</span>
            </div>`;

            map.fitBounds(bounds);
            document.getElementById('info').innerHTML = infoText;
            
            // ì´¬ì˜ ì¥ì†Œ ì„ íƒ ëª¨ë“œë¡œ ì „í™˜
            isSelectingShooter = true;
        }

        // ì´¬ì˜ ì¥ì†Œê°€ ì„ íƒë˜ì—ˆì„ ë•Œ ì‹¤í–‰ë˜ëŠ” í•µì‹¬ ê³„ì‚° í•¨ìˆ˜
        function calculateShootingMoment() {
            if (!targetPosition || !shooterPosition) return;

            // 1. í•„ìš”í•œ ê°’ ìˆ˜ì§‘
            const tLat = targetPosition.lat();
            const tLng = targetPosition.lng();
            const sLat = shooterPosition.lat();
            const sLng = shooterPosition.lng();
            
            // ê±°ë¦¬ ê³„ì‚° (ë¯¸í„°)
            const dist = google.maps.geometry.spherical.computeDistanceBetween(targetPosition, shooterPosition);
            
            // ë†’ì´ ì •ë³´ (ì‚¬ìš©ì ì…ë ¥ ë¬¼ì²´ ë†’ì´)
            const objHeight = parseFloat(document.getElementById('targetObjectHeight').value) || 0;

            // 2. í•„ìš” ê³ ë„ê°(Elevation Angle) ê³„ì‚° (ì§€êµ¬ ê³¡ë¥  & ëŒ€ê¸° êµ´ì ˆ ë³´ì • ì ìš©)
            // ë³´ì • ê³µì‹: Î”h = (1 - k) * d^2 / (2 * R)
            // d: ê±°ë¦¬(m), R: ì§€êµ¬ ë°˜ì§€ë¦„(6371000m), k: ëŒ€ê¸° êµ´ì ˆ ê³„ìˆ˜(í‘œì¤€ 0.13)
            // íƒ€ê²Ÿì´ ê³¡ë¥  ë•Œë¬¸ì— ë‚´ë ¤ê°€ ë³´ì„ -> íƒ€ê²Ÿ ë†’ì´ì—ì„œ ì°¨ê°í•´ì•¼ í•¨.
            
            const R = 6371000;
            const k = 0.13; // í‘œì¤€ ëŒ€ê¸° êµ´ì ˆ ê³„ìˆ˜
            const correction = (1 - k) * (dist * dist) / (2 * R); // ë¯¸í„° ë‹¨ìœ„ ë³´ì •ê°’ (ë‚´ë ¤ê°€ëŠ” ì–‘)

            // ì‹œë‚˜ë¦¬ì˜¤ A: íƒ€ê²Ÿì˜ 'ë°”ë‹¥(ì§€ë©´)'ì— ë‹¬ì´ ë‹¿ëŠ” ìˆœê°„ (Moonrise)
            // ë³´ì •ëœ íƒ€ê²Ÿ ë†’ì´ = ì‹¤ì œ íƒ€ê²Ÿ ë†’ì´ - ê³¡ë¥ íš¨ê³¼
            const effectiveTargetElevBase = (targetElevation || 0) - correction;
            const altDiffBase = effectiveTargetElevBase - (shooterElevation || 0);
            
            let requiredAltAngleBase = (Math.atan2(altDiffBase, dist) * 180 / Math.PI);
            if (requiredAltAngleBase < -0.5) requiredAltAngleBase = -0.5;

            // ì‹œë‚˜ë¦¬ì˜¤ B: íƒ€ê²Ÿì˜ 'ê¼­ëŒ€ê¸°(ë¬¼ì²´ ìƒë‹¨)'ì— ë‹¬ì´ ë‹¿ëŠ” ìˆœê°„ (Moonset)
            const effectiveTargetElevTop = ((targetElevation || 0) + objHeight) - correction;
            const altDiffTop = effectiveTargetElevTop - (shooterElevation || 0);
            
            let requiredAltAngleTop = (Math.atan2(altDiffTop, dist) * 180 / Math.PI);
            if (requiredAltAngleTop < -0.5) requiredAltAngleTop = -0.5;

            // 3. íƒìƒ‰ ë° ê³„ì‚°
            const dateStr = document.getElementById('dateInput').value;
            const baseDate = new Date(dateStr + "T12:00:00");
            const moonTimes = SunCalc.getMoonTimes(baseDate, sLat, sLng);
            
            let candidates = [];

            // (A) ì›”ì¶œ(Moonrise) ê¸°ì¤€ íƒìƒ‰ -> 'ì§€í‘œ(Base)' ë†’ì´ì— ë„ë‹¬í•˜ëŠ” ì‹œê° ì°¾ê¸°
            if (moonTimes.rise) {
                let startTime = new Date(moonTimes.rise.getTime() - 30*60000);
                for (let i = 0; i < 720; i++) {
                    const time = new Date(startTime.getTime() + i * 60000);
                    // SunCalc ëŒ€ì‹  ë³´ì •ëœ í•¨ìˆ˜ ì‚¬ìš©
                    const pos = getCorrectedMoonPosition(time, sLat, sLng);
                    const alt = pos.altitude * 180 / Math.PI;
                    if (alt >= requiredAltAngleBase) {
                        candidates.push({
                            time: time,
                            azimuth: (pos.azimuth * 180 / Math.PI) + 180,
                            type: 'Moonrise',
                            desc: 'ì§€ë©´(Base) ë„ë‹¬',
                            angle: requiredAltAngleBase
                        });
                        break;
                    }
                }
            }

            // (B) ì›”ëª°(Moonset) ê¸°ì¤€ íƒìƒ‰ -> 'ê¼­ëŒ€ê¸°(Top)' ë†’ì´ì— ê±¸ë¦¬ëŠ” ì‹œê° ì°¾ê¸°
            if (moonTimes.set) {
                let startTime = new Date(moonTimes.set.getTime() - 6*60*60000);
                let foundSet = null;
                for (let i = 0; i < 420; i++) {
                    const time = new Date(startTime.getTime() + i * 60000);
                    // SunCalc ëŒ€ì‹  ë³´ì •ëœ í•¨ìˆ˜ ì‚¬ìš©
                    const pos = getCorrectedMoonPosition(time, sLat, sLng);
                    const alt = pos.altitude * 180 / Math.PI;
                    if (alt > requiredAltAngleTop) {
                        foundSet = { time: time, azimuth: (pos.azimuth * 180 / Math.PI) + 180 };
                    } else if (alt <= requiredAltAngleTop && foundSet) {
                        candidates.push({
                            time: foundSet.time,
                            azimuth: foundSet.azimuth,
                            type: 'Moonset',
                            desc: 'ê¼­ëŒ€ê¸°(Top) ê±¸ë¦¼',
                            angle: requiredAltAngleTop
                        });
                        break;
                    }
                }
            }

            // ê²°ê³¼ í‘œì‹œ HTML ìƒì„± (ë®ì–´ì“°ì§€ ì•Šê³  ì¶”ê°€)
            let shotResultHtml = "";
            
            if (candidates.length > 0) {
                // ì‚¬ìš©ìê°€ ì°ì€ ìœ„ì¹˜ê°€ ì›”ì¶œ ìª½ì¸ì§€ ì›”ëª° ìª½ì¸ì§€ íŒë‹¨
                const shooterToTargetBearing = google.maps.geometry.spherical.computeHeading(shooterPosition, targetPosition);
                let bearing = (shooterToTargetBearing + 360) % 360;
                
                let bestShot = candidates[0];
                let minDiff = 360;
                
                candidates.forEach((shot, idx) => {
                    let diff = Math.abs(shot.azimuth - bearing);
                    if (diff > 180) diff = 360 - diff;
                    if (diff < minDiff) {
                        minDiff = diff;
                        bestShot = shot;
                    }
                });

                const timeStr = bestShot.time.toLocaleString([], {month: 'numeric', day: 'numeric', hour: '2-digit', minute:'2-digit'});
                
                // ê°ë„ë¥¼ DMS(ë„/ë¶„/ì´ˆ)ë¡œ ë³€í™˜
                const aziDMS = toDMS(bestShot.azimuth);
                const altDMS = toDMS(bestShot.angle);
                const tLatStr = targetPosition.lat().toFixed(6);
                const tLngStr = targetPosition.lng().toFixed(6);
                const sLatStr = shooterPosition.lat().toFixed(6);
                const sLngStr = shooterPosition.lng().toFixed(6);

                // ë°•ìŠ¤ ìŠ¤íƒ€ì¼ë¡œ í‘œì‹œ
                shotResultHtml = `
                <div style="background:#f9f9f9; border:1px solid #ddd; border-radius:8px; padding:10px; margin-top:10px; display:flex; align-items:center; justify-content:space-between;">
                    <div>
                        ğŸ“ ê±°ë¦¬: <strong>${(dist/1000).toFixed(2)}km</strong><br>
                        ğŸ“¸ <strong>${bestShot.type} Shot:</strong> <span style="font-size:1.1em; color:#d32f2f; font-weight:bold;">${timeStr}</span><br>
                        <span style="font-size:0.9em; color:#555;">${bestShot.desc} (í•„ìš”ê°: ${altDMS})</span><br>
                        <span style="font-size:0.9em; color:#0056b3;">ğŸŒ• ë‹¬ ìœ„ì¹˜: ë°©ìœ„ê° ${aziDMS} / ê³ ë„ ${altDMS}</span><br>
                        <span style="font-size:0.8em; color:#888;">* ê³¡ë¥  ë³´ì •: -${correction.toFixed(1)}m</span>
                    </div>
                    <div style="text-align:right; font-size:0.8em; color:#666; line-height:1.4em;">
                         Shooter: ${shooterElevation}m<br>
                         (${sLatStr}, ${sLngStr})<br>
                         Target: ${targetElevation}m (+${objHeight}m)<br>
                         (${tLatStr}, ${tLngStr})
                    </div>
                </div>
                <div style="margin-top:5px; font-size:0.9em; color:#666;">
                    ğŸ‘‰ ì§€ë„ì— í‘œì‹œëœ <strong>ë¶‰ì€ ì„ </strong>ì´ ë‹¬ì˜ ë°©í–¥ì…ë‹ˆë‹¤.
                </div>
                `;
                
                drawRedLine(shooterPosition, bestShot.azimuth);
            } else {
                shotResultHtml = `<div style="color:red; margin-top:10px;">âš ï¸ í•´ë‹¹ ìœ„ì¹˜ì—ì„œëŠ” ë‹¬ì´ íƒ€ê²Ÿ ê°ë„ ë²”ìœ„ì— ë“¤ì–´ì˜¤ì§€ ì•ŠìŠµë‹ˆë‹¤.</div>`;
            }

            // ê¸°ì¡´ ì •ë³´ëŠ” ê±´ë“œë¦¬ì§€ ì•Šê³ , ê²°ê³¼ ì˜ì—­ë§Œ ì—…ë°ì´íŠ¸
            document.getElementById('shot-result').innerHTML = shotResultHtml;
        }

        function drawRedLine(center, bearing) {
             if (shootingLinePath) shootingLinePath.setMap(null);

             const distance = 50000; // 50km
             const endPoint = computeOffset(center, distance, bearing);

             shootingLinePath = new google.maps.Polyline({
                path: [center, endPoint],
                geodesic: true,
                strokeColor: "#FF0000", // ë¹¨ê°„ìƒ‰
                strokeOpacity: 1.0,
                strokeWeight: 2,
                map: map
            });
        }

        function drawShootingLine(center, bearing, color) {
            // 50km ê¸¸ì´ì˜ ì„  ê³„ì‚°
            const distance = 50000;
            const endPoint = computeOffset(center, distance, bearing);

            const lineCoordinates = [
                center, // íƒ€ê²Ÿ ìœ„ì¹˜
                endPoint // ì´¬ì˜ì ë°©í–¥ ëì 
            ];

            // ì„  ê·¸ë¦¬ê¸°
            return new google.maps.Polyline({
                path: lineCoordinates,
                geodesic: true,
                strokeColor: color,
                strokeOpacity: 0.8,
                strokeWeight: 4,
                icons: [{
                    icon: {path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW},
                    offset: '100%'
                }],
                map: map
            });
        }

        // [ë³´ì¡° í•¨ìˆ˜] íŠ¹ì • ì¢Œí‘œì—ì„œ ê±°ë¦¬(m), ë°©ìœ„ê°(deg) ë§Œí¼ ì´ë™í•œ ì¢Œí‘œ ê³„ì‚°
        function computeOffset(latLng, distance, bearing) {
            const R = 6371000; // ì§€êµ¬ ë°˜ì§€ë¦„ (m)
            const lat1 = latLng.lat() * Math.PI / 180; // rad
            const lon1 = latLng.lng() * Math.PI / 180; // rad
            const brng = bearing * Math.PI / 180; // rad

            const lat2 = Math.asin(Math.sin(lat1) * Math.cos(distance / R) +
                        Math.cos(lat1) * Math.sin(distance / R) * Math.cos(brng));
            const lon2 = lon1 + Math.atan2(Math.sin(brng) * Math.sin(distance / R) * Math.cos(lat1),
                        Math.cos(distance / R) - Math.sin(lat1) * Math.sin(lat2));

            return {
                lat: lat2 * 180 / Math.PI,
                lng: lon2 * 180 / Math.PI
            };
        }

        function getMoonPhaseIcon(phase) {
            // phase: 0.0(New Moon) -> 0.25(First Quarter) -> 0.5(Full Moon) -> 0.75(Last Quarter) -> 1.0
            if (phase < 0.05 || phase > 0.95) return "ğŸŒ‘"; // ì‚­
            if (phase < 0.2) return "ğŸŒ’"; // ì´ˆìŠ¹ë‹¬
            if (phase < 0.3) return "ğŸŒ“"; // ìƒí˜„ë‹¬
            if (phase < 0.45) return "ğŸŒ”"; // ìƒí˜„ë§ê°„
            if (phase < 0.55) return "ğŸŒ•"; // ë³´ë¦„ë‹¬
            if (phase < 0.7) return "ğŸŒ–"; // í•˜í˜„ë§ê°„
            if (phase < 0.8) return "ğŸŒ—"; // í•˜í˜„ë‹¬
            return "ğŸŒ˜"; // ê·¸ë¯ë‹¬
        }

        function getPhaseName(phase) {
            if (phase < 0.05 || phase > 0.95) return "New Moon (ì‚­)";
            if (phase < 0.2) return "Waxing Crescent (ì´ˆìŠ¹ë‹¬)";
            if (phase < 0.3) return "First Quarter (ìƒí˜„ë‹¬)";
            if (phase < 0.45) return "Waxing Gibbous";
            if (phase < 0.55) return "Full Moon (ë³´ë¦„ë‹¬)";
            if (phase < 0.7) return "Waning Gibbous";
            if (phase < 0.8) return "Last Quarter (í•˜í˜„ë‹¬)";
            return "Waning Crescent (ê·¸ë¯ë‹¬)";
        }
        
        function toDMS(deg) {
            const d = Math.floor(deg);
            const m = Math.floor((deg - d) * 60);
            const s = ((deg - d) * 60 - m) * 60;
            return `${d}Â° ${m}' ${s.toFixed(1)}"`;
        }
    </script>
</body>
</html>